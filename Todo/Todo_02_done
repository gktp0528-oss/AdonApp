# Adon 결제 페이지 구현 계획 (2026-02-13)

## 목표
- 결제 화면을 단순 UI가 아니라 **거래 상태머신 + 에스크로** 중심으로 설계한다.
- 거래 방식 3종 지원:
  - `직거래(meetup)`
  - `택배(delivery)`
  - `무인 택배함(locker)`
- 거래 완료 이후 후기 시스템으로 자연스럽게 연결 가능한 구조를 만든다.

---

## 1) 제품 원칙

### 핵심 원칙
1. 결제 성공 = 판매자 즉시 정산 아님  
   - 기본 상태는 `paid_held`(보류금)
2. 거래 완료 신호가 있어야 정산
   - 구매자 확정 또는 자동확정 타이머
3. 분쟁 상태에서는 정산 중단
4. 거래 방식별 입력/검증/상태 전이가 다르게 동작

### 성공 기준 (MVP)
- 결제 생성부터 거래 완료까지 상태가 끊기지 않고 추적 가능
- 보안 규칙으로 당사자 외 조작 불가
- 실패/취소/분쟁 경로가 최소 1회 이상 검증 완료

---

## 2) 사용자 플로우

### A. 직거래 (meetup)
1. 상품 상세 → `결제하기`
2. 결제 페이지에서 거래 방식 `직거래` 선택
3. 날짜/시간/장소 입력 및 합의
4. 결제 완료 → `paid_held`
5. 만남 시 QR/코드 인증(양측)
6. 구매자 `거래 완료` 누름 → `buyer_confirmed`
7. 정산 실행 → `released`

### B. 택배 (delivery)
1. 거래 방식 `택배` 선택
2. 배송지/수령인/연락처 입력
3. 결제 완료 → `paid_held`
4. 판매자 발송 등록(송장번호) → `shipped`
5. 배송 완료 이벤트/수동 완료 → `delivered`
6. 구매자 확정 또는 자동확정 → `released`

### C. 무인 택배함 (locker)
1. 거래 방식 `무인 택배함` 선택
2. 락커 지점/보관 슬롯 선택
3. 결제 완료 → `paid_held`
4. 판매자 보관 완료(입고 코드) → `deposited`
5. 구매자 수령 코드 인증 → `picked_up`
6. 구매자 확인 → `released`

---

## 3) 결제 페이지 UI 뼈대

### 섹션 구성
1. 주문 요약
   - 상품 썸네일, 제목, 가격
2. 금액 상세
   - 상품가, 배송비, 수수료, 총 결제금액
3. 거래 방식 선택
   - 직거래 / 택배 / 무인 택배함
4. 방식별 입력 폼
   - 직거래: 시간/장소
   - 택배: 주소/수령인/연락처
   - 락커: 지점/예정 시간
5. 결제수단
   - 카드/간편결제/계좌
6. 에스크로 안내
   - 보류금/해제 조건/자동확정 시점
7. 약관 동의
   - 환불/분쟁/개인정보
8. 하단 고정 CTA
   - 최종 금액 + `결제하기`

### 필수 검증
- 거래 방식 미선택 시 결제 차단
- 필수 입력 누락 시 인라인 에러
- 약관 미동의 시 결제 차단

---

## 4) 상태머신 설계

### 공통 상태
- `initiated`
- `pending_payment`
- `paid_held`
- `released`
- `cancelled`
- `disputed`
- `refunded`

### 방식별 중간 상태
- 직거래: `meetup_scheduled` → `met_verified` → `buyer_confirmed`
- 택배: `shipped` → `delivered` → `buyer_confirmed`
- 락커: `locker_reserved` → `deposited` → `picked_up` → `buyer_confirmed`

### 자동확정 정책
- 택배: `delivered` + N일(예: 2~3일) 무분쟁 시 자동 `buyer_confirmed`
- 직거래/락커: 인증 신호 없으면 자동확정 없음(초기 MVP 권장)

---

## 5) 데이터 모델 (Firestore)

### `transactions/{transactionId}`
- `listingId: string`
- `conversationId: string`
- `buyerId: string`
- `sellerId: string`
- `tradeType: 'meetup' | 'delivery' | 'locker'`
- `status: string` (상태머신 값)
- `escrowStatus: 'pending_payment' | 'paid_held' | 'released' | 'refunded'`
- `amount`:  
  - `item: number`
  - `shipping: number`
  - `platformFee: number`
  - `total: number`
  - `currency: 'EUR' | 'KRW' ...`
- `paymentMethod: string`
- `paymentProviderRef?: string`
- `confirmBy?: Timestamp` (자동확정 기준 시각)
- `meetup?: { date, time, place, buyerCheckin, sellerCheckin }`
- `delivery?: { recipientName, phone, address, carrier, trackingNo }`
- `locker?: { provider, locationId, slotId, dropoffCode, pickupCode }`
- `dispute?: { openedBy, reason, openedAt, status }`
- `createdAt: Timestamp`
- `updatedAt: Timestamp`

### `transactions/{transactionId}/events/{eventId}`
- 상태 전이 로그(누가, 언제, 무엇을 변경했는지)

---

## 6) 권한/보안 규칙

### 기본 원칙
1. 거래 당사자만 read
2. 상태 전이는 허용된 경로로만 update
3. 금액 필드는 생성 이후 임의 변경 금지
4. `released/refunded`는 서버(Cloud Function)만 처리 권장

### Rules 최소 요구
- `request.auth.uid in [buyerId, sellerId]`
- 상태값 whitelist 검사
- `escrowStatus` 임의 변경 차단

---

## 7) 백엔드 처리

### Cloud Functions 권장 작업
1. 결제 성공 webhook 수신 → `paid_held`
2. 배송완료/락커수령 신호 반영
3. 자동확정 스케줄 실행
4. 정산 실행(`released`) 및 실패 재시도
5. 분쟁 상태 진입 시 정산 중지

---

## 8) 구현 단계 (개발 순서)

### Phase 1 - 결제 화면 + 거래 생성 (필수)
1. `PaymentScreen` UI 뼈대
2. 거래 방식 선택/검증
3. `transactions` 문서 생성 (`pending_payment`)

### Phase 2 - 에스크로 상태 연결 (필수)
1. 결제 성공 시 `paid_held`
2. 거래 방식별 중간 상태 전이 버튼
3. 거래 상세 상태 페이지 구현

### Phase 3 - 자동화/운영 (권장)
1. 자동확정 타이머
2. 분쟁/취소/환불 플로우
3. 정산 로그/이벤트 로그

### Phase 4 - 후기 연동 (후속)
1. `released` 전환 후 후기 CTA 오픈
2. 거래 1건당 후기 1회 제한

---

## 9) QA 체크리스트

1. 각 거래 방식에서 필수 입력 누락 시 결제 차단되는가
2. 결제 성공 후 상태가 반드시 `paid_held`로 저장되는가
3. 당사자 외 사용자 접근 시 권한 거부되는가
4. 분쟁 중에는 `released`로 넘어가지 않는가
5. 자동확정 시각이 정확히 동작하는가
6. 앱 재실행/네트워크 불안정 상황에서도 상태 일관성이 유지되는가

---

## 10) 지표 (런칭 후)

1. 결제 진입 대비 결제 완료율
2. 거래 방식별 완료율 (`meetup`, `delivery`, `locker`)
3. 분쟁률/환불률
4. `paid_held -> released` 평균 소요시간
5. 후기 작성 전환율

---

## 11) 즉시 실행 TODO

1. `transactions` 타입/컬렉션 스키마 확정
2. `PaymentScreen` 라우트 추가 및 기본 UI 구현
3. 거래 방식별 입력 폼 컴포넌트 분리
4. 결제 버튼 클릭 시 `pending_payment` 생성 API 연결
5. Firestore rules 초안 작성 및 Emulator 테스트
